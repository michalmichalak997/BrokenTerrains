#include <fstream>
#include <sstream>
#include <string>
#define _USE_MATH_DEFINES
#include <math.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Projection_traits_xy_3.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <vector>
#include <random>
#include <CGAL/point_generators_2.h>
#include <CGAL/Random.h>
#include <CGAL/Polygon_2.h>
#include <cstdlib> 
#include <ctime>

using namespace std;


typedef CGAL::Exact_predicates_inexact_constructions_kernel            Kernel;
typedef CGAL::Projection_traits_xy_3<Kernel> Gt;
typedef CGAL::Triangulation_vertex_base_with_info_2< unsigned int, Gt > Vb;
typedef CGAL::Triangulation_data_structure_2<Vb>                       Tds;
typedef CGAL::Delaunay_triangulation_2<Gt, Tds>                    Delaunay;
typedef CGAL::Polygon_2<Kernel>                                     Polygon_2;

typedef Kernel::Point_2                                                  Point_2;

typedef Kernel::Iso_rectangle_2                                  Rectangle_2;
typedef std::vector<Point_2>                                        Container;
typedef CGAL::Random_points_in_square_2<Point_2>                  Point_i_generator;
typedef CGAL::Random_points_on_square_2<Point_2>                  Point_o_generator;

typedef Kernel::Point_3                                                Point;

const int n = 3; //we work in 3D
//double coord_coef;
//const double eps = 0.98; //to avoid zero-division - the product of lengths of unit vectors should be about 1
double converter = 180 / M_PI; // converts radians to angles and vice versa

class plane //a class that stores the crucial figures in terms of computing the orientation
{

private:
	Point first_point;            //the first point of a triangle
	Point second_point;            //the second point of a triangle
	Point third_point;            //the third_point of a triangle

	vector <double> first_vec;            //the first edge of a triangle
	vector <double> second_vec;			//the second edge of a triangle
	vector <double> third_vec;			//the third edge of a triangle
	vector <double> normal_vec;			//normal vector of a triangle
	vector <double> directional;			//the projection of the normal vector onto the horizontal plane
	vector <double> z_axis = { 0,0,1 };   //the definition of the z-axis
	vector <double> dip_vec;
	double doc;						//a variable that contains the collinearity coefficient
	double area;					//a variable that stores the area of a triangle
	bool lin_dependence;		    //a bool variable to check to answer whether points are (too) collinear
	string dip_degrees;             //a text variable to store the dip angle
	string azimuth_degrees;         //a text variable to store the dip direction

public:
	static const int n = 3;			//the dimension of vectors
	const double ex = 2;			//we introduce the restriction of collinearity - it should be between 0 and 1 to actually work
	double dip_azimuth(vector<double> normal, int n = 2) //a function that computes the dip azimuth
	{
		double angle = atan2(normal[1], normal[0]);
		angle = angle * converter;
		if (angle < 0)
		{
			return angle + 360;
		}
		else
		{
			return angle;
		}
	}

	double dip_angle(vector<double> z_axis, vector<double> normal_v) //function that computes the dip angle
{
	double angle;
	double numerator = abs(dot_product(z_axis, normal_v));
	//double denominator = plane::length(plane1.get_normal()) * plane::length(plane2.get_normal());
	if (numerator >= 1.0) {
		return 0;
	}
	else {
		return acos(numerator) * converter;
	}
}

	static double dot_product(vector<double> vector_line, vector<double> direction, int n = 3) //function that computes the dot product of vectors
	{
		double product = 0;
		for (int i = 0; i < n; i++)
		{
			product += direction[i] * vector_line[i];
		}
		return product;
	}

	bool dependence(vector<double> v1, vector<double> v2, vector<double> v3) //function that checks whether the points are collinear
	{
		double len_v1 = length(v1);
		double len_v2 = length(v2);
		double len_v3 = length(v3);
		double lengths[n] = { len_v1, len_v2, len_v3 };

		sort(lengths, lengths + n);
		this->doc = lengths[2] / (lengths[0] + lengths[1]);
		int k = 0;
		for (int i = 0; i < n; i++)
		{
			if (lengths[i] == 0)
			{
				k += 1;
			}
		}
		if (k != 0)
		{
			return true;
		}
		else
		{
			if (doc > ex)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	}


	/*
	void get_normal(double v1[], double v2[], int n = 3)//function that computes the normal vector
	{
		normal_vec[0] = v1[1] * v2[2] - v2[1] * v1[2];
		normal_vec[1] = v1[2] * v2[0] - v2[2] * v1[0];
		normal_vec[2] = v1[0] * v2[1] - v2[0] * v1[1];
	}
	*/

	static double length(vector<double> line_vector, int n = 3) //function that computes the length of a vector
	{
		double vector_length = sqrt(pow(line_vector[0], 2) + pow(line_vector[1], 2) + pow(line_vector[2], 2));
		return vector_length;
	}

	vector<double> get_dip() {

		vector<double> dip_vector = { dip_vec[0],dip_vec[1] ,dip_vec[2] };
		return(dip_vector);
	}
	// czy w kodzie do monokliny jest zamienione na x()

	vector <string> center() //function that computes the geometrical centre of a triangle, usuwane
	{
		double x = (first_point.x() + second_point.x() + third_point.x()) / (3.0);
		double y = (first_point.y() + second_point.y() + third_point.y()) / (3.0);
		double z = (first_point.z() + second_point.z() + third_point.z()) / (3.0);
		vector<string> napis{ to_string(x), to_string(y), to_string(z) };
		return napis;
	}

	plane(Point point_1, Point point_2, Point point_3) //the class constructor
	{

		this->first_point = Point(point_1.x(), point_1.y(), point_1.z());
		this->second_point = Point(point_2.x(), point_2.y(), point_2.z());
		this->third_point = Point(point_3.x(), point_3.y(), point_3.z());

		//double coeff = 180 / M_PI;

		vector<double>  first_try = { point_2.x() - point_1.x(), point_2.y() - point_1.y(), point_2.z() - point_1.z() };
		vector<double>  second_try = { point_3.x() - point_1.x(), point_3.y() - point_1.y(), point_3.z() - point_1.z() };
		vector<double>  third_try = { point_3.x() - point_2.x(), point_3.y() - point_2.y(), point_3.z() - point_2.z() };

		bool test = dependence(first_try, second_try, third_try);
		if (test == true)
		{
			lin_dependence = true;
		}
		else
		{
			lin_dependence = false;
			for (int i = 0; i < n; i++)
			{
				this->first_vec.push_back(first_try[i]);
				this->second_vec.push_back(second_try[i]);
				this->third_vec.push_back(third_try[i]);
			}
			normal_vec.push_back(first_vec[1] * second_vec[2] - second_vec[1] * first_vec[2]);
			normal_vec.push_back(first_vec[2] * second_vec[0] - second_vec[2] * first_vec[0]);
			normal_vec.push_back(first_vec[0] * second_vec[1] - second_vec[0] * first_vec[1]);

			if (normal_vec[2] < 0) {
				normal_vec[0] *= -1;
				normal_vec[1] *= -1;
				normal_vec[2] *= -1;
			}

			double normal_length = length(normal_vec);
			normal_vec[0] = normal_vec[0] / normal_length;
			normal_vec[1] = normal_vec[1] / normal_length;
			normal_vec[2] = normal_vec[2] / normal_length;

			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * cos(dip_azimuth(normal_vec) / converter));
			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * sin(dip_azimuth(normal_vec) / converter));
			dip_vec.push_back(-sin(dip_angle(z_axis, normal_vec) / converter));

			/*
			double stala = 0.5;
			double half = stala * (length(first_vec) + length(second_vec) + length(third_vec));
			double s = sqrt(half * (half - length(first_vec)) * (half - length(second_vec)) * (half - length(third_vec)));
			this->area = s * 0.0001;*/
		}


		/*          plane(vector<double> point_1, vector<double> point_2, vector<double> point_3) //the class constructor
		{
			for (int i = 0; i < n; i++)
			{
				first_point.push_back(point_1[i]);
				second_point.push_back(point_2[i]);
				third_point.push_back(point_3[i]);
			}

			vector<double> first_try;
			vector<double> second_try;
			vector<double> third_try;

			for (int i = 0; i < n; i++)
			{
				first_try.push_back(point_2[i] - point_1[i]);
				second_try.push_back(point_3[i] - point_1[i]);
				third_try.push_back(point_3[i] - point_2[i]);
			}

			bool test = dependence(first_try, second_try, third_try);
			if (test == true)
			{
				lin_dependence = true;
			}
			else
			{
				lin_dependence = false;
				for (int i = 0; i < n; i++)
				{
					this->first_vec.push_back(first_try[i]);
					this->second_vec.push_back(second_try[i]);
					this->third_vec.push_back(third_try[i]);
				}
				normal_vec.push_back(first_vec[1] * second_vec[2] - second_vec[1] * first_vec[2]);
				normal_vec.push_back(first_vec[2] * second_vec[0] - second_vec[2] * first_vec[0]);
				normal_vec.push_back(first_vec[0] * second_vec[1] - second_vec[0] * first_vec[1]);

				if (normal_vec[2] < 0) {
					normal_vec[0] *= -1;
					normal_vec[1] *= -1;
					normal_vec[2] *= -1;
				}


				double normal_length = length(normal_vec);
				normal_vec[0] = normal_vec[0] / normal_length;
				normal_vec[1] = normal_vec[1] / normal_length;
				normal_vec[2] = normal_vec[2] / normal_length;

				dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * cos(dip_azimuth(normal_vec) / converter));
				dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / converter) * sin(dip_azimuth(normal_vec) / converter));
				dip_vec.push_back(-sin(dip_angle(z_axis, normal_vec) / converter));

				double stala = 0.5;
				double half = stala * (length(first_vec) + length(second_vec) + length(third_vec));
				double s = sqrt(half * (half - length(first_vec)) * (half - length(second_vec)) * (half - length(third_vec)));
				this->area = s * 0.0001;
			}



		}         */
	}
	string get_dip_angle() {

		return this->dip_degrees;
	}

	string get_azimuth() {

		return this->azimuth_degrees;
	}


	vector<double> get_normal() //function that -computes- returns the normal vector
	{

		vector<double> normal_vector = { normal_vec[0] ,normal_vec[1], normal_vec[2] };

		return normal_vector;
	}

	string measure()//function that supplies orientation results also for singularities
	{
		if (lin_dependence) // result for collinear points
		{
			azimuth_degrees = ("LT");
			dip_degrees = ("LT");
			return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[0] == 0 && normal_vec[1] == 0 && normal_vec[2] != 0) //result for a horizontal triangle
		{
			dip_degrees = "0";
			azimuth_degrees = ("x");
			return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[2] == 0) //result for a vertical triangle
		{
			dip_degrees = "90";
			azimuth_degrees = to_string(dip_azimuth(normal_vec));
			return dip_degrees + ";" + azimuth_degrees;
		}
		else //a normal case (no singularities)
		{
			double dipping_angle = dip_angle(z_axis, normal_vec);
			dip_degrees = to_string(dipping_angle);
			azimuth_degrees = to_string(dip_azimuth(normal_vec));
			return dip_degrees + ";" + azimuth_degrees;
		}
	}
};




double angle_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = abs(plane::dot_product(plane1.get_normal(), plane2.get_normal()));
	//double denominator = plane::length(plane1.get_normal()) * plane::length(plane2.get_normal());
	if (numerator>= 1.0) {
		return 0;
	}
	else {
		return acos(numerator) * converter;
	}

}
/*
	if (denominator < eps) { return -9999; }
		else {

		try {
			double help = acos(numerator / denominator) * converter;
			if (!isnan(help)) { return help;}
			else {
				throw(help);
			}
		}
		catch (double help) {
			
			cout << "Problem with the angle, because angle is: " << help << endl;
			cout << "Numerator (dot product between normal vectors) is: " << numerator << endl;
			cout << "Denominator (product between lengths) is: " << denominator << endl;
			cout << "Ratio between numerator and denominator is: " << numerator / denominator << endl;
			cout << "Arcus cosinus is: " << acos(numerator / denominator) << endl;
			cout << "Normal vector of the first plane: [" << plane1.get_normal()[0] << "," << plane1.get_normal()[1] << "," << plane1.get_normal()[1] << "]" << endl;
			cout << "Normal vector of the second plane: [" << plane2.get_normal()[0] << "," << plane2.get_normal()[1] << "," << plane2.get_normal()[1] << "]" << endl << endl;
		}
		}
}
*/
double euclidean_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_normal();
	vector<double>second_dip = plane2.get_normal();
	return sqrt(pow(first_dip[0] - second_dip[0], 2) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_normal(), plane2.get_normal());
	//double denominator = plane::length(plane1.get_normal()) * plane::length(plane2.get_normal());
	return 1-numerator;
}

double angle_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_dip(), plane2.get_dip());
	//double denominator = plane::length(plane1.get_dip()) * plane::length(plane2.get_dip());
	if (numerator <= -1.0) {
		return 180;
	}
	else if (numerator >= 1.0) {
		return 0;
	}
	else {
		return acos(numerator) * converter;
	}
}

double euclidean_between_dip_vectors(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_dip();
	vector<double>second_dip = plane2.get_dip();
	return sqrt(pow(first_dip[0] - second_dip[0], 2) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double numerator = plane::dot_product(plane1.get_dip(), plane2.get_dip());
	//double denominator=	plane::length(plane1.get_dip()) * plane::length(plane2.get_dip());
	//if (denominator < eps) { return -9999; }
	//else {
	return  1-numerator;
	//}
}

void save_delaunay_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {

	ofstream delaunays(path);

	delaunays <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_vertices() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "
		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";

	for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
	{
		delaunays << fixed << (it->first[2]) << "\n          ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
	{
		double x = (it->first[1]), y = (it->first[0]), z = (it->first[2]);
		delaunays << fixed << x << " " << y << " " << z << "\n           ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;
		delaunays << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";

		//cout << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 3; i <= 3 * dt.number_of_faces(); i = i + 3)
	{
		delaunays << i << " ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		delaunays << 5 << " ";
	}

	delaunays << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";

}


void save_normals_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {


	ofstream normalvis(path);
	std::pair<Point, int> point_1; //we have a pair with point and index of the point
	std::pair<Point, int> point_2;
	std::pair<Point, int> point_3;
	normalvis <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		//point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
		//point_1[1] = dt.triangle(face)[0][1];
		//point_1[2] = dt.triangle(face)[0][2];
		//point_1[3] = face->vertex(0)->info();

		//point_2[0] = dt.triangle(face)[1][0];
		//point_2[1] = dt.triangle(face)[1][1];
		//point_2[2] = dt.triangle(face)[1][2];
		//point_2[3] = face->vertex(1)->info();

		//point_3[0] = dt.triangle(face)[2][0];
		//point_3[1] = dt.triangle(face)[2][1];
		//point_3[2] = dt.triangle(face)[2][2];
		//point_3[3] = face->vertex(2)->info();

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
		normalvis << fixed << centroid[2] << "\n          ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();

		normalvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (auto i = 0; i < dt.number_of_faces(); i++)
	{
		normalvis << i << "\n          ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		normalvis << i << " ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		normalvis << 1 << " ";
	}

	normalvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"<CellData Normals=\"cell_normals\">" << "\n      " <<
		"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;

		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

		double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
		double y_n = current_plane.get_normal()[1];
		double z_n = current_plane.get_normal()[2];

		//vector<double> normal_vector_double = { x_n, y_n, z_n };
		//x_n = x_n / plane::length(normal_vector_double);
		//y_n = y_n / plane::length(normal_vector_double);
		//z_n = z_n / plane::length(normal_vector_double);

		normalvis << fixed << y_n << " " << x_n << " " << z_n << "\n          ";
	}

	normalvis <<
		"</DataArray>" << "\n      " <<
		"</CellData>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";

	
}


void save_dips_vtk(Delaunay dt, vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod, string path) {


	ofstream dipsvis(path);
	std::pair<Point, int> point_1; //we have a pair with point and index of the point
	std::pair<Point, int> point_2;
	std::pair<Point, int> point_3;
	dipsvis <<
		"<?xml version=\"1.0\"?>" << "\n" <<
		"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
		"<UnstructuredGrid>" << "\n    " <<
		"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

		"<PointData Scalars=\"scalars\">" << "\n        "
		"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
		dipsvis << fixed << centroid[2] << "\n          ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</PointData>" << "\n      " <<
		"<Points>" << "\n        " <<
		"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

	{
		Delaunay::Face_handle face = fit;
		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();

		dipsvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Points>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

	for (auto i = 0; i < dt.number_of_faces(); i++)
	{
		dipsvis << i << "\n          ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		dipsvis << i << " ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n        " <<
		"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
		"\n          ";

	for (auto i = 1; i <= dt.number_of_faces(); i++)
	{
		dipsvis << 1 << " ";
	}

	dipsvis << "\n        " <<
		"</DataArray>" << "\n      " <<
		"</Cells>" << "\n    " <<
		"<CellData Normals=\"cell_normals\">" << "\n      " <<
		"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


	for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
	{
		Delaunay::Face_handle face = fit;

		point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
		point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
		point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

		plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
		string result = current_plane.measure();								//extracting the dip angle and the dip direction
		vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

		double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
		double y_d = current_plane.get_dip()[1];
		double z_d = current_plane.get_dip()[2];

		vector<double> dip_vector_double = { x_d, y_d, z_d };
		//x_d = x_d / plane::length(dip_vector_double);
		//y_d = y_d / plane::length(dip_vector_double);
		//z_d = z_d / plane::length(dip_vector_double);

		dipsvis << fixed << y_d << " " << x_d << " " << z_d << "\n          ";
	}

	dipsvis <<
		"</DataArray>" << "\n      " <<
		"</CellData>" << "\n      " <<
		"<Cells>" << "\n        " <<
		"</Cells>" << "\n    " <<
		"</Piece>" << "\n  " <<
		"</UnstructuredGrid>" << "\n" <<
		"</VTKFile>";
}

void save_model_parameters(string path_params,
	int number_of_files, //number of files generated
	int left_terrain_size, int right_terrain_size, //lower and upper bound for the set of terrain sizes
	int left_range_azimuth, int right_range_azimuth, //for azimuth
	double min_terrain_dip, double max_terrain_dip, //for the dip 
	int left_number_triangulation, int right_number_triangulation, // lower and upper bound for the number of points in the triangulation
	double left_surface_noise, double right_surface_noise, // bounds for the noise introduced to the surface
	double left_fault_throw, double right_fault_throw, //bounds for the values of fault throw	
	vector <std::pair<double, double>> orientation) {

	ofstream save_params(path_params);

	save_params << "Number of files: " << number_of_files << "\n" <<
		"Left terrain size: " << left_terrain_size << "\n" <<
		"Right terrain size: " << right_terrain_size << "\n" <<
		"Left range azimuth given: " << left_range_azimuth << "\n" <<
		"Right range azimuth given: " << right_range_azimuth << "\n" <<
		"Minimum dip given: " << min_terrain_dip << "\n" <<
		"Maximum dip terrain given: " << max_terrain_dip << "\n" <<
		"Lower bound for points in the triangulation: " << left_number_triangulation << "\n" <<
		"Upper bound for points in the triangulation: " << right_number_triangulation << "\n" <<
		"Lower bound for noise: " << left_surface_noise << "\n" <<
		"Upper bound for noise: " << right_surface_noise << "\n" <<
		"Lower bound for fault throw: " << left_fault_throw << "\n" <<
		"Upper bound for fault throw: " << right_fault_throw;

	save_params << endl;
	save_params << "Orientations are as follows:" << endl;
	for (int i=0; i != number_of_files; ++i) {

		save_params << "For the " << to_string(i) << "-file we have:  " "Dip ang: " << orientation.at(i).first << ".  Dip direction: " << orientation.at(i).second << "." << endl;
	
	}



}

int main()
{

	std::random_device rd;
	std::default_random_engine re(rd());
	int number_of_files; //number of files generated
	int left_terrain_size, right_terrain_size; //lower and upper bound for the set of terrain sizes
	int left_range_azimuth, right_range_azimuth; //for azimuth
	double min_terrain_dip, max_terrain_dip; //for the dip 
	int left_number_triangulation, right_number_triangulation; // lower and upper bound for the number of points in the triangulation
	double left_surface_noise, right_surface_noise; // bounds for the noise introduced to the surface
	double left_fault_throw, right_fault_throw; //bounds for the values of fault throw



	std::cout << "This is generator of faulted triangulated surfaces. We need to introduce some parameters." << std::endl;
	std::cout << "How many files (terrains) do you want?" << endl;
	std::cin >> number_of_files;
	std::cout << "There are " << number_of_files << " files" << endl;
	std::cout << "If the size of the terrain should not be constant, specify different bounds ({left_terrain_size,...,right_terrain_size})" << std::endl;
	std::cin >> left_terrain_size >> right_terrain_size;
	cout << "The terrain sizes will be randomly selected from the set: {" << left_terrain_size << ",...," << right_terrain_size << "}" << endl;
	std::uniform_int_distribution<int> random_terrain_size(left_terrain_size, right_terrain_size);
	std::cout << "Specify minimum and maximum value of dip for the terrain, The dip should not be greater than 30 degrees" << endl;
	std::cin >> min_terrain_dip >> max_terrain_dip;
	cout << "The minimum dip is: " << min_terrain_dip << ". And the maximum dip is: " << max_terrain_dip << endl;
	if (max_terrain_dip > 30) throw runtime_error("s");
	std::uniform_real_distribution<double> random_dip(min_terrain_dip, max_terrain_dip);
	std::cout << "Specify directional range for the azimuth. For example, if all azimuth should be considered, enter 0 and 360." << endl;
	std::cin >> left_range_azimuth >> right_range_azimuth;
	std::cout << "The left bound of azimuth is: " << left_range_azimuth << ". And the right bound for azimuth is: " << right_range_azimuth << endl;
	std::uniform_int_distribution<int> random_azimuth(left_range_azimuth, right_range_azimuth);
	std::cout << "If the number of points in the terrain should not be constant, specify different bounds ({left_number_triangulation,...,right_number_triangulation})" << endl;
	std::cin >> left_number_triangulation >> right_number_triangulation;
	cout << "The lower bound for points in the triangulation is: " << left_number_triangulation << ". And the upper bound for points in the triangulation is: " << right_number_triangulation << endl;
	std::uniform_int_distribution<int> random_points_triangulation(left_number_triangulation, right_number_triangulation);
	std::cout << "Specify lower and upper bound of noise introduced to the surface (typically below 0.1)" << endl;
	cin >> left_surface_noise >> right_surface_noise;
	std::cout << "The lower bound for noise is: " << left_surface_noise << " . And the upper bound for surface noise is:" << right_surface_noise << endl;
	std::uniform_real_distribution<double> surface_unif(left_surface_noise, right_surface_noise);
	std::cout << "What are the lower and upper bounds for fault throw?" << endl;
	cin >> left_fault_throw >> right_fault_throw;
	std::cout << "The lower bound for fault throw: " << left_fault_throw << " . And the upper bound for fault throw:" << right_fault_throw << endl;
	std::uniform_real_distribution<double> fault_unif(left_fault_throw, right_fault_throw); //determines the 
	std::cout << "The files are being generated..." << endl;

	/*the data below are needed for simulating fault throws in the surface. We assume
that the upper bound for fault throw depends on the maximum dip angle in the data set.
 We want to consider the maximum throw as a fraction of the elevation difference between the maximum possible dip in the data set.
 Therefore, we specify a plane dipping to N with maximum dip.
 We know that the points are sampled from a square centered at (0,0) and the corner coordinates (a,a), where "a" is the argument of the sampling function.
 Therefore, without losing generality, we can consider points with coordinates (a,0) and (-a,0).
 The distance between these points is 2a.
 We calculate a normal vector to the surface.
 From the coordinates of the normal vector, we can derive elevation (Z) coordinates for points (a,0) and (-a,0).

*/
	int user_dip_direction = 0;
	double user_dip_angle = max_terrain_dip;
	double n_max_x = -sin(user_dip_angle / converter) * cos(user_dip_direction / converter);
	double n_max_z = -cos(user_dip_angle / converter);
	double max_elev_diff = 2 * right_terrain_size * abs(n_max_x / n_max_z);



	vector <int> sample_dipdir; //the surfaces will have a random dip dir and random dip direction
	vector <double> sample_dipang;
	vector <std::pair<double, double>> orientation;
	for (int i = 0; i < number_of_files; i++) { //sample values of dip direction
		sample_dipdir.push_back(random_azimuth(re)); //random_azimuth(re)
	}

	for (int i = 0; i < number_of_files; i++) { //sample values of dip angle - because we have a terrain, we have a maximum limit for dip angle
		sample_dipang.push_back(random_dip(re)); //random_dip(re)
	}

	for (int i = 0; i < number_of_files; i++) { //sample orientation
		orientation.push_back(make_pair(sample_dipang[i], sample_dipdir[i]));
	}

	vector <vector<double>>  poles;
	vector <double> triplet;

	/*cout << "x=" << -sin(max_terrain_dip / converter) * cos(0 / converter) <<
		"Y=" << -sin(max_terrain_dip / converter) * sin(0 / converter) <<
		"Z=" << -cos(max_terrain_dip / converter) << endl; */


	for (int i = 0; i < number_of_files; i++) {
		double x=-sin(orientation[i].first / converter) * cos(orientation[i].second / converter);
		double y=-sin(orientation[i].first / converter) * sin(orientation[i].second / converter);
		double z= -cos(orientation[i].first / converter);
		if (z < 0) {
			x = x * -1;
			y = y * -1;
			z = z * -1;
		}
		triplet.push_back(x);
		triplet.push_back(y);
		triplet.push_back(z);
		//cout << "x=" << triplet.at(0) << "y=" << triplet.at(1) << "Z=" << triplet.at(2) << "length=" << sqrt(triplet.at(0)*triplet.at(0)+triplet.at(1)*triplet.at(1)+triplet.at(2)*triplet.at(2)) << endl;
		poles.push_back(triplet);
		triplet.clear();
	}

	string path_params = "C:\\testy\\scikit7\\params.txt";
	save_model_parameters(
		path_params, 
	 number_of_files, //number of files generated
	 left_terrain_size, right_terrain_size, //lower and upper bound for the set of terrain sizes
	 left_range_azimuth, right_range_azimuth, //for azimuth
	 min_terrain_dip, max_terrain_dip, //for the dip 
	left_number_triangulation, right_number_triangulation, // lower and upper bound for the number of points in the triangulation
	 left_surface_noise, right_surface_noise, // bounds for the noise introduced to the surface
	 left_fault_throw, right_fault_throw, //bounds for the values of fault throw	
		orientation);

	int i = 1; //name or number of the file

	while (i < number_of_files)
	{
		string file_path = "C:\\testy\\scikit7\\";
		file_path.append(to_string(i));
		file_path.append(".txt");

		ofstream saving(file_path);
		saving << 
			"Dip_angle;" << "Dip_direction;" <<
			"X_C;" << "Y_C;" << "Z_C;" <<
			"X_N;" << "Y_N;" << "Z_N;" <<
			"X_D;" << "Y_D;" << "Z_D;" <<
			"X_C_Neighbor1;" << "Y_C_Neighbor1;" << "Z_C_Neighbor1;" <<
			"X_C_Neighbor2;" << "Y_C_Neighbor2;" << "Z_C_Neighbor2;" <<
			"X_C_Neighbor3;" << "Y_C_Neighbor3;" << "Z_C_Neighbor3;" <<

			"EuclideanNeighbor1_N;" << "EuclideanNeighbor2_N;" << "EuclideanNeighbor3_N;" <<
			"AngleNeighbor1_N;" << "AngleNeighbor2_N;" << "AngleNeighbor3_N;" <<
			"CosineNeighbor1_N;" << "CosineNeighbor2_N;" << "CosineNeighbor3_N;" <<


			"EuclideanNeighbor1_D;" << "EuclideanNeighbor2_D;" << "EuclideanNeighbor3_D;" <<
			"AngleNeighbor1_D;" << "AngleNeighbor2_D;" << "AngleNeighbor3_D;" <<
			"CosineNeighbor1_D;" << "CosineNeighbor2_D;" << "CosineNeighbor3_D;" <<


			"n1_xn;" << "n1_yn;" << "n1_zn;" <<
			"n2_xn;" << "n2_yn;" << "n2_zn;" <<
			"n3_xn;" << "n3_yn;" << "n3_zn;" <<
			"n1_xd;" << "n1_yd;" << "n1_zd;" <<
			"n2_xd;" << "n2_yd;" << "n2_zd;" <<
			"n3_xd;" << "n3_yd;" << "n3_zd;" <<
			"File_number;" <<
			"IDT1;" << "IDT2;" << "IDT3;" <<
			"Fault" << endl;

		//std::uniform_int_distribution<int> number_of_points(10, 100);

		vector<Point_2> points_f; //vector for storing fault lines

		Point_o_generator f(random_terrain_size(re)); // faults (f), argument denotes the size of a square, the points representing a fault line lie on the boundary of the square, because we have an outside generator

		std::copy_n(f, 2, back_inserter(points_f));

		if ((points_f[0].x() == points_f[1].x()) || (points_f[0].y() == points_f[1].y())) { //we don't want ideally vertical or horizontal fault lines, because in extreme cases (if the fault line lies on the boundary), all points from the domain would have the same label
			double x3 = points_f[0].x();
			double y3 = points_f[0].y();

			points_f.erase(points_f.begin());
			points_f.insert(points_f.begin(), Point_2(y3, x3));
		}


		vector<Point_2> points_b; //vector for storing boreholes/points
		Point_i_generator b(random_terrain_size(re)); // boreholes (b), argument denotes the size of a square, adding 100 points inside (because we have an inside generator)

		std::copy_n(b, random_points_triangulation(re), back_inserter(points_b));

		vector<Point> points_b_inclined; //we must add elevation


		for (auto it = points_b.begin(); it != points_b.end(); it++) {
			points_b_inclined.push_back(Point((*it).x(), (*it).y(), -poles[i][0] * (*it).x() - poles[i][1] * (*it).y())); // z=-2x-3y, web.me.utexas.edu, find an equation for the plane passing through the point Q(0,0,0) and parallel to the plane 2x+3y+z=5
		}

		auto& greatest_elev = *max_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);
		auto& smallest_elev = *min_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);


		//cout << "greatest elevation:" << greatest_elev << endl;
		//cout << "smallest elevation:" << smallest_elev << endl;

		//auto interval_of_surface_noise = elevation_difference * surface_unif(re);  // determines what fraction of the elevation difference (max-min) can be added as noise to elevation data, e.g. 10%*980-780, where 980 and 780 are max and min elevation values, respectively
		//double lower_bound = -interval_of_surface_noise / 2;
		//double upper_bound = interval_of_surface_noise / 2;
		//std::uniform_real_distribution<double> noise_surface(lower_bound, upper_bound);
		//std::uniform_int_distribution<int> random_throw(0, 2*number_of_files); //we want to have enough possible fault throws
		//ouble fault_throw_fraction; //determines the fraction of elevation difference used for the fault throw
		//double value_of_fault_throw; //a vector for storing throws
		//for (int i = 0; i < number_of_files * 2; i++) {
			//fault_throw_fraction=fault_unif(re); //fractions are generated

		auto elevation_difference = greatest_elev.z() - smallest_elev.z(); //elevation difference is claculated for each terrain seperately
		auto value_of_fault_throw = fault_unif(re) * max_elev_diff; //fault throws are generated; for example 1.1547 is the maximum elevation difference between points on a terrain with maximum dip=30 with size 1, (it has a normal vector [-0.5,0,-0.86], therefore 1*Z=-0.5/0.86=-0.57735, 2*1(size)*-0.57735=1.1547)




		vector<Point> points_b_inclined_noise; //we must add noise to elevation

		for (auto it = points_b_inclined.begin(); it != points_b_inclined.end(); it++) {
			points_b_inclined_noise.push_back(Point((*it).x(), (*it).y(), (*it).z() + elevation_difference * surface_unif(re) )); // 
		}


		vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod;//this data structure is necessary for VTK visualization, an integer must be added to represent each point in the VTK structure
		auto number_of_point = 1; //necessary for VTK visualization
		for (auto it = points_b_inclined_noise.begin(); it != points_b_inclined_noise.end(); it++)
		{

			switch (CGAL::orientation(
				Point_2(points_f[0].x(), points_f[0].y()),
				Point_2(points_f[1].x(), points_f[1].y()),
				Point_2((*it).x(), (*it).y()))
				)
			{
			case CGAL::LEFT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z() - value_of_fault_throw), number_of_point)); break;
			case CGAL::RIGHT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z()), number_of_point)); break;
			case CGAL::COLLINEAR:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), -9999999), number_of_point)); break;
			}

			number_of_point++;
		}

		Delaunay dt;

		dt.insert(points_b_inclined_noise_mod.begin(), points_b_inclined_noise_mod.end());
		vector <plane> planes; //a vector variable storing planes representing the second surface
		std::pair<Point, int> point_1; //we have a pair with point and index of the point
		std::pair<Point, int> point_2;
		std::pair<Point, int> point_3;

		Point n1_point_1; //three coordinates: XYZ of neighbors
		Point n1_point_2;
		Point n1_point_3;

		Point n2_point_1;
		Point n2_point_2;
		Point n2_point_3;

		Point n3_point_1;
		Point n3_point_2;
		Point n3_point_3;


		Kernel::Line_2 f1(Point_2(points_f[0].x(), points_f[0].y()), Point_2(points_f[1].x(), points_f[1].y())); //creating one fault line


		for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

		{
			Delaunay::Face_handle face = fit;
			point_1 = make_pair(Point(dt.triangle(face)[0][0], dt.triangle(face)[0][1], dt.triangle(face)[0][2]), face->vertex(0)->info());
			point_2 = make_pair(Point(dt.triangle(face)[1][0], dt.triangle(face)[1][1], dt.triangle(face)[1][2]), face->vertex(1)->info());
			point_3 = make_pair(Point(dt.triangle(face)[2][0], dt.triangle(face)[2][1], dt.triangle(face)[2][2]), face->vertex(2)->info());

			try {
				planes.push_back(plane(point_1.first, point_2.first, point_3.first));
			}
			catch (exception e) {

				cout << e.what() << endl;
			}
			/*point_1.push_back(dt.triangle(face)[0][0]); //extracting coordinates of points building a Delaunay triangle
			point_1.push_back(dt.triangle(face)[0][1]);
			point_1.push_back(dt.triangle(face)[0][2]);
			point_1.push_back(face->vertex(0)->info());



			point_2.push_back(dt.triangle(face)[1][0]);
			point_2.push_back(dt.triangle(face)[1][1]);
			point_2.push_back(dt.triangle(face)[1][2]);
			point_2.push_back(face->vertex(1)->info());


			point_3.push_back(dt.triangle(face)[2][0]);
			point_3.push_back(dt.triangle(face)[2][1]);
			point_3.push_back(dt.triangle(face)[2][2]);
			point_3.push_back(face->vertex(2)->info());*/

			Point_2 t1(dt.triangle(face)[0][0], //extracting coordinates of points building a Delaunay triangle
				dt.triangle(face)[0][1]);

			Point_2 t2(dt.triangle(face)[1][0],
				dt.triangle(face)[1][1]);

			Point_2 t3(dt.triangle(face)[2][0],
				dt.triangle(face)[2][1]);

			//	cout << "p1:" << t1 << ", p2:" << t2 << ", t3:" << t3 << endl;

			plane current_plane = plane(point_1.first, point_2.first, point_3.first);					//constructing a plane that is processed at the moment
			string result = current_plane.measure();								//extracting the dip angle and the dip direction
			vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

			double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double y_n = current_plane.get_normal()[1];
			double z_n = current_plane.get_normal()[2];

			//x_n = x_n / plane::length(current_plane.get_normal());
			//y_n = y_n / plane::length(current_plane.get_normal());
			//z_n = z_n / plane::length(current_plane.get_normal());

			double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double y_d = current_plane.get_dip()[1];
			double z_d = current_plane.get_dip()[2];

			//x_d = x_d / plane::length(current_plane.get_dip());
			//y_d = y_d / plane::length(current_plane.get_dip());
			//z_d = z_d / plane::length(current_plane.get_dip());

			//Normal vectors of neighbors

			double n1_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n1_y_n;
			double n1_z_n;

			double n2_x_n;//extracting coordinates of the normal vector of a planar Delaunay triangle
			double n2_y_n;
			double n2_z_n;

			double n3_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n3_y_n;
			double n3_z_n;

			//Dip vectors of neighbors
			double d1_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d1_y_d;
			double d1_z_d;

			double d2_x_d;//extracting coordinates of the dip vector of a planar Delaunay triangle
			double d2_y_d;
			double d2_z_d;

			double d3_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d3_y_d;
			double d3_z_d;


			//1st neighbor
			double n_euclidean1 = -9999;
			double n_angle1 = -9999;
			double n_cos1 = -9999;
			double d_euclidean1 = -9999;
			double d_angle1 = -9999;
			double d_cos1 = -9999;
			vector<string> centroid_n1;

			if (dt.is_infinite(face->neighbor(0)) == true) {


				n1_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n1_y_n = -9999;
				n1_z_n = -9999;
				d1_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d = -9999;
				d1_z_d = -9999;
				centroid_n1.push_back("undefined");
				centroid_n1.push_back("undefined");
				centroid_n1.push_back("undefined");
				//n_euclidean1, n_angle1, n_cos1, n_euclidean1, d_angle1, d_cos1 = -9999;
			}
			else {
				n1_point_1 = Point(dt.triangle(face->neighbor(0))[0][0], dt.triangle(face->neighbor(0))[0][1], dt.triangle(face->neighbor(0))[0][2]);


				n1_point_2 = Point(dt.triangle(face->neighbor(0))[1][0], dt.triangle(face->neighbor(0))[1][1], dt.triangle(face->neighbor(0))[1][2]);


				n1_point_3 = Point(dt.triangle(face->neighbor(0))[2][0], dt.triangle(face->neighbor(0))[2][1], dt.triangle(face->neighbor(0))[2][2]);

				plane neighbor1_plane = plane(n1_point_1, n1_point_2, n1_point_3);
				n1_x_n = neighbor1_plane.get_normal()[0];// / plane::length(neighbor1_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n1_y_n = neighbor1_plane.get_normal()[1]; /// plane::length(neighbor1_plane.get_normal());
				n1_z_n = neighbor1_plane.get_normal()[2]; /// plane::length(neighbor1_plane.get_normal());

				d1_x_d = neighbor1_plane.get_dip()[0]; // plane::length(neighbor1_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d = neighbor1_plane.get_dip()[1]; // plane::length(neighbor1_plane.get_dip());
				d1_z_d = neighbor1_plane.get_dip()[2]; // plane::length(neighbor1_plane.get_dip());


				centroid_n1 = neighbor1_plane.center();


				n_euclidean1 = euclidean_between_normals(current_plane, neighbor1_plane);
				n_angle1 = angle_between_normals(current_plane, neighbor1_plane);
				n_cos1 = cosine_distance_between_normals(current_plane, neighbor1_plane);

				d_euclidean1 = euclidean_between_dip_vectors(current_plane, neighbor1_plane);
				d_angle1 = angle_between_dips(current_plane, neighbor1_plane);
				d_cos1 = cosine_distance_between_dips(current_plane, neighbor1_plane);
			}


			//2nd neighbor
			double n_euclidean2 = -9999;
			double n_angle2 = -9999;
			double n_cos2 = -9999;
			double d_euclidean2 = -9999;
			double d_angle2 = -9999;
			double d_cos2 = -9999;
			vector<string> centroid_n2;


			if (dt.is_infinite(face->neighbor(1)) == true) {


				n2_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n2_y_n = -9999;
				n2_z_n = -9999;


				d2_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d2_y_d = -9999;
				d2_z_d = -9999;
				centroid_n2.push_back("undefined");
				centroid_n2.push_back("undefined");
				centroid_n2.push_back("undefined");
				//n_euclidean2, n_angle2, n_cos2, n_euclidean2, d_angle2, d_cos2= -9999;
			}
			else {
				n2_point_1 = Point(dt.triangle(face->neighbor(1))[0][0], dt.triangle(face->neighbor(1))[0][1], dt.triangle(face->neighbor(1))[0][2]);


				n2_point_2 = Point(dt.triangle(face->neighbor(1))[1][0], dt.triangle(face->neighbor(1))[1][1], dt.triangle(face->neighbor(1))[1][2]);


				n2_point_3 = Point(dt.triangle(face->neighbor(1))[2][0], dt.triangle(face->neighbor(1))[2][1], dt.triangle(face->neighbor(1))[2][2]);


				plane neighbor2_plane = plane(n2_point_1, n2_point_2, n2_point_3);

				n2_x_n = neighbor2_plane.get_normal()[0]; // plane::length(neighbor2_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
					n2_y_n = neighbor2_plane.get_normal()[1]; // plane::length(neighbor2_plane.get_normal());
					n2_z_n = neighbor2_plane.get_normal()[2]; // plane::length(neighbor2_plane.get_normal());

					d2_x_d = neighbor2_plane.get_dip()[0]; // plane::length(neighbor2_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
					d2_y_d = neighbor2_plane.get_dip()[1]; // plane::length(neighbor2_plane.get_dip());
					d2_z_d = neighbor2_plane.get_dip()[2]; // plane::length(neighbor2_plane.get_dip());

				centroid_n2 = neighbor2_plane.center();


				n_euclidean2 = euclidean_between_normals(current_plane, neighbor2_plane);
				n_angle2 = angle_between_normals(current_plane, neighbor2_plane);
				n_cos2 = cosine_distance_between_normals(current_plane, neighbor2_plane);

				d_euclidean2 = euclidean_between_dip_vectors(current_plane, neighbor2_plane);
				d_angle2 = angle_between_dips(current_plane, neighbor2_plane);
				d_cos2 = cosine_distance_between_dips(current_plane, neighbor2_plane);
			}


			//3 neighbor

			double n_euclidean3 = -9999;
			double n_angle3 = -9999;
			double n_cos3 = -9999;
			double d_euclidean3 = -9999;
			double d_angle3 = -9999;
			double  d_cos3 = -9999;
			vector<string> centroid_n3;


			if (dt.is_infinite(face->neighbor(2)) == true) {

				n3_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n3_y_n = -9999;
				n3_z_n = -9999;

				d3_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d3_y_d = -9999;
				d3_z_d = -9999;

				centroid_n3.push_back("undefined");
				centroid_n3.push_back("undefined");
				centroid_n3.push_back("undefined");
				//n_euclidean3, n_angle3, n_cos3, n_euclidean3, d_angle3, d_cos3 = -9999;
			}
			else {
				n3_point_1 = Point(dt.triangle(face->neighbor(2))[0][0], dt.triangle(face->neighbor(2))[0][1], dt.triangle(face->neighbor(2))[0][2]);

				n3_point_2 = Point(dt.triangle(face->neighbor(2))[1][0], dt.triangle(face->neighbor(2))[1][1], dt.triangle(face->neighbor(2))[1][2]);

				n3_point_3 = Point(dt.triangle(face->neighbor(2))[2][0], dt.triangle(face->neighbor(2))[2][1], dt.triangle(face->neighbor(2))[2][2]);


				plane neighbor3_plane = plane(n3_point_1, n3_point_2, n3_point_3);

				n3_x_n = neighbor3_plane.get_normal()[0]; // plane::length(neighbor3_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
					n3_y_n = neighbor3_plane.get_normal()[1]; // plane::length(neighbor3_plane.get_normal());
					n3_z_n = neighbor3_plane.get_normal()[2]; /// plane::length(neighbor3_plane.get_normal());

				centroid_n3 = neighbor3_plane.center();


				d3_x_d = neighbor3_plane.get_dip()[0]; // plane::length(neighbor3_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
					d3_y_d = neighbor3_plane.get_dip()[1]; // plane::length(neighbor3_plane.get_dip());
					d3_z_d = neighbor3_plane.get_dip()[2]; // plane::length(neighbor3_plane.get_dip());

				n_euclidean3 = euclidean_between_normals(current_plane, neighbor3_plane);
				n_angle3 = angle_between_normals(current_plane, neighbor3_plane);
				n_cos3 = cosine_distance_between_normals(current_plane, neighbor3_plane);

				d_euclidean3 = euclidean_between_dip_vectors(current_plane, neighbor3_plane);
				d_angle3 = angle_between_dips(current_plane, neighbor3_plane);
				d_cos3 = cosine_distance_between_dips(current_plane, neighbor3_plane);
			}


			bool intersect = CGAL::do_intersect(Kernel::Triangle_2(t1, t2, t3), f1);

			saving <<
				current_plane.get_dip_angle() << ";" <<
				current_plane.get_azimuth() << ";" <<
				centroid[0] << ";" <<
				centroid[1] << ";" <<
				centroid[2] << ";" <<
				x_n << ";" << y_n << ";" << z_n << ";" <<
				x_d << ";" << y_d << ";" << z_d << ";" <<
				centroid_n1[0] << ";" << centroid_n1[1] << ";" << centroid_n1[2] << ";" <<
				centroid_n2[0] << ";" << centroid_n2[1] << ";" << centroid_n2[2] << ";" <<
				centroid_n3[0] << ";" << centroid_n3[1] << ";" << centroid_n3[2] << ";" <<

				n_euclidean1 << ";" << n_euclidean2 << ";" << n_euclidean3 << ";" <<
				n_angle1 << ";" << n_angle2 << ";" << n_angle3 << ";" <<
				n_cos1 << ";" << n_cos2 << ";" << n_cos3 << ";" <<

				d_euclidean1 << ";" << d_euclidean2 << ";" << d_euclidean3 << ";" <<
				d_angle1 << ";" << d_angle2 << ";" << d_angle3 << ";" <<
				d_cos1 << ";" << d_cos2 << ";" << d_cos3 << ";" <<


				n1_x_n << ";" << n1_y_n << ";" << n1_z_n << ";" <<
				n2_x_n << ";" << n2_y_n << ";" << n2_z_n << ";" <<
				n3_x_n << ";" << n3_y_n << ";" << n3_z_n << ";" <<
				d1_x_d << ";" << d1_y_d << ";" << d1_z_d << ";" <<
				d2_x_d << ";" << d2_y_d << ";" << d2_z_d << ";" <<
				d3_x_d << ";" << d3_y_d << ";" << d3_z_d << ";" <<
				i << ";" <<
				face->vertex(0)->info()<< ";" << //id start
				face->vertex(1)->info() << ";" <<
				face->vertex(2)->info() << ";" << //id end
				intersect << endl;

		//	string path_del = "C:\\testy\\scikit7\\";
		//	path_del.append(to_string(i));
		//	path_del.append("_delaunay.vtu");
		//	ofstream delaunays(path_del);




			

	//		string path_normals = "C:\\testy\\scikit7\\";
		//	path_normals.append(to_string(i));
		//	path_normals.append("_normals.vtu");
		//	ofstream normalvis(path_normals);

			

			//VTK file for Dip vectors

		//	string path_dips = "C:\\testy\\scikit7\\";
		//	path_dips.append(to_string(i));
		//	path_dips.append("_dips.vtu");
		//	ofstream dipsvis(path_dips);

			





			//the end of the big for loop

			//point_1.clear();
			//point_2.clear();
			//point_3.clear();

			//n1_point_1.clear();
			//n1_point_2.clear();
			//n1_point_3.clear();

//			n2_point_1.clear();
	//		n2_point_2.clear();
		//	n2_point_3.clear();

			//n3_point_1.clear();
			//n3_point_2.clear();
			//n3_point_3.clear();
		}

		string file_path_del = "C:\\testy\\scikit7\\";
		file_path_del.append(to_string(i) + "_delaunay.vtu");
		string file_path_nor = "C:\\testy\\scikit7\\";
		file_path_nor.append(to_string(i) + "_normals.vtu");
		string file_path_dips = "C:\\testy\\scikit7\\";
		file_path_dips.append(to_string(i) + "_dips.vtu");

		save_delaunay_vtk(dt, points_b_inclined_noise_mod, file_path_del);
		save_normals_vtk(dt, points_b_inclined_noise_mod, file_path_nor);
		save_dips_vtk(dt, points_b_inclined_noise_mod, file_path_dips);



		i++;
	}


	system("pause");
	return 0;
}
