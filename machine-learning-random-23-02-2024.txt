#include <fstream>
#include <sstream>
#include <string>
#define _USE_MATH_DEFINES
#include <math.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Projection_traits_xy_3.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <vector>
#include <random>
#include <CGAL/point_generators_2.h>
#include <CGAL/Random.h>
#include <CGAL/Polygon_2.h>
#include <cstdlib> 
#include <ctime>

using namespace std;


typedef CGAL::Exact_predicates_inexact_constructions_kernel            Kernel;
typedef CGAL::Projection_traits_xy_3<Kernel> Gt;
typedef CGAL::Triangulation_vertex_base_with_info_2< unsigned int, Gt > Vb;
typedef CGAL::Triangulation_data_structure_2<Vb>                       Tds;
typedef CGAL::Delaunay_triangulation_2<Gt, Tds>                    Delaunay;
typedef CGAL::Polygon_2<Kernel>                                     Polygon_2;

typedef Kernel::Point_2                                                  Point_2;

typedef Kernel::Iso_rectangle_2                                  Rectangle_2;
typedef std::vector<Point_2>                                        Container;
typedef CGAL::Random_points_in_square_2<Point_2>                  Point_i_generator;
typedef CGAL::Random_points_on_square_2<Point_2>                  Point_o_generator;

typedef Kernel::Point_3                                                Point;

const int n = 3; //we work in 3D
//double coord_coef;


class plane //a class that stores the crucial figures in terms of computing the orientation
{

private:
	vector <double> first_point;            //the first point of a triangle
	vector <double> second_point;            //the second point of a triangle
	vector <double> third_point;            //the third_point of a triangle

	vector <double> first_vec;            //the first edge of a triangle
	vector <double> second_vec;			//the second edge of a triangle
	vector <double> third_vec;			//the third edge of a triangle
	vector <double> normal_vec;			//normal vector of a triangle
	vector <double> directional;			//the projection of the normal vector onto the horizontal plane
	vector <double> z_axis = { 0,0,1 };   //the definition of the z-axis
	vector <double> dip_vec;
	double doc;						//a variable that contains the collinearity coefficient
	double area;					//a variable that stores the area of a triangle
	bool lin_dependence;		    //a bool variable to check to answer whether points are (too) collinear
	string dip_degrees;             //a text variable to store the dip angle
	string azimuth_degrees;         //a text variable to store the dip direction

public:
	static const int n = 3;			//the dimension of vectors
	const double ex = 2;			//we introduce the restriction of collinearity
	double dip_azimuth(vector<double> normal, int n = 2) //a function that computes the dip azimuth
	{
		double coeff = 180 / M_PI;
		double angle = atan2(normal[1], normal[0]);
		angle = angle * coeff;
		if (angle < 0)
		{
			return angle + 360;
		}
		else
		{
			return angle;
		}
	}

	double dip_angle(vector<double> z_axis, vector<double> normal_v) //function that computes the dip angle
	{
		double angle;
		double expression;
		double coeff = 180 / M_PI;
		expression = abs(dot_product(z_axis, normal_v)) / (length(z_axis) * length(normal_v));
		angle = acos(expression);
		return angle * coeff;
	}

	static double dot_product(vector<double> vector_line, vector<double> direction, int n = 3) //function that computes the dot product of vectors
	{
		double product = 0;
		for (int i = 0; i < n; i++)
		{
			product += direction[i] * vector_line[i];
		}
		return product;
	}

	bool dependence(vector<double> v1, vector<double> v2, vector<double> v3) //function that checks whether the points are collinear
	{
		double len_v1 = length(v1);
		double len_v2 = length(v2);
		double len_v3 = length(v3);
		double lengths[n] = { len_v1, len_v2, len_v3 };

		sort(lengths, lengths + n);
		this->doc = lengths[2] / (lengths[0] + lengths[1]);
		int k = 0;
		for (int i = 0; i < n; i++)
		{
			if (lengths[i] == 0)
			{
				k += 1;
			}
		}
		if (k != 0)
		{
			return true;
		}
		else
		{
			if (doc > ex)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	}


	/*
	void get_normal(double v1[], double v2[], int n = 3)//function that computes the normal vector
	{
		normal_vec[0] = v1[1] * v2[2] - v2[1] * v1[2];
		normal_vec[1] = v1[2] * v2[0] - v2[2] * v1[0];
		normal_vec[2] = v1[0] * v2[1] - v2[0] * v1[1];
	}
	*/

	static double length(vector<double> line_vector, int n = 3) //function that computes the length of a vector
	{
		double vector_length = sqrt(pow(line_vector[0], 2) + pow(line_vector[1], 2) + pow(line_vector[2], 2));
		return vector_length;
	}

	vector<double> get_dip() {

		vector<double> dip_vector = {dip_vec[0],dip_vec[1] ,dip_vec[2] };
		return(dip_vector);
	}


	vector <string> center() //function that computes the geometrical centre of a triangle, usuwane
	{
		double x = (first_point[0] + second_point[0] + third_point[0]) / (3.0);
		double y = (first_point[1] + second_point[1] + third_point[1]) / (3.0);
		double z = (first_point[2] + second_point[2] + third_point[2]) / (3.0);

		vector<string> napis{ to_string(x), to_string(y), to_string(z) };
		return napis;
	}

	plane(vector<double> point_1, vector<double> point_2, vector<double> point_3) //the class constructor
	{
		for (int i = 0; i < n; i++)
		{
			first_point.push_back(point_1[i]);
			second_point.push_back(point_2[i]) ;
			third_point.push_back(point_3[i]) ;
		}


		double coeff = 180 / M_PI;
		vector<double> first_try;
		vector<double> second_try;
		vector<double> third_try;

		for (int i = 0; i < n; i++)
		{
			first_try.push_back(point_2[i] - point_1[i]);
			second_try.push_back(point_3[i] - point_1[i]);
			third_try.push_back(point_3[i] - point_2[i]);
		}

		bool test = dependence(first_try, second_try, third_try);
		if (test == true)
		{
			lin_dependence = true;
		}
		else
		{
			lin_dependence = false;
			for (int i = 0; i < n; i++)
			{
				this->first_vec.push_back(first_try[i]);
				this->second_vec.push_back(second_try[i]);
				this->third_vec.push_back(third_try[i]);
			}
			normal_vec.push_back( first_vec[1] * second_vec[2] - second_vec[1] * first_vec[2]);
			normal_vec.push_back(first_vec[2] * second_vec[0] - second_vec[2] * first_vec[0]);
			normal_vec.push_back(first_vec[0] * second_vec[1] - second_vec[0] * first_vec[1]);

			if (normal_vec[2] < 0) {
				normal_vec[0] *= -1;
				normal_vec[1] *= -1;
				normal_vec[2] *= -1;
			}

			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / coeff) * cos(dip_azimuth(normal_vec) / coeff)) ;
			dip_vec.push_back(cos(dip_angle(z_axis, normal_vec) / coeff) * sin(dip_azimuth(normal_vec) / coeff)) ;
			dip_vec.push_back(-sin(dip_angle(z_axis, normal_vec) / coeff));

			double stala = 0.5;
			double half = stala * (length(first_vec) + length(second_vec) + length(third_vec));
			double s = sqrt(half * (half - length(first_vec)) * (half - length(second_vec)) * (half - length(third_vec)));
			this->area = s * 0.0001;
		}



	}

	vector<double> get_normal() //function that -computes- returns the normal vector
	{

		vector<double> normal_vector = { normal_vec[0] ,normal_vec[1], normal_vec[2] };

		return normal_vector;
	}

	string measure()//function that supplies orientation results also for singularities
	{
		if (lin_dependence) // result for collinear points
		{
			azimuth_degrees = ("LT");
			dip_degrees = ("LT");
			return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[0] == 0 && normal_vec[1] == 0 && normal_vec[2] != 0) //result for a horizontal triangle
		{
			dip_degrees = "0";
			azimuth_degrees = ("x");
			return (dip_degrees + ";" + azimuth_degrees);
		}
		else if (normal_vec[2] == 0) //result for a vertical triangle
		{
			dip_degrees = "90";
			azimuth_degrees = to_string(dip_azimuth(normal_vec));
			return dip_degrees + ";" + azimuth_degrees;
		}
		else //a normal case (no singularities)
		{
			double dipping_angle = dip_angle(z_axis, normal_vec);
			dip_degrees = to_string(dipping_angle);
			azimuth_degrees = to_string(dip_azimuth(normal_vec));
			return dip_degrees + ";" + azimuth_degrees;
		}
	}
};


double angle_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double coeff = 180 / M_PI;
	double expression = abs(plane::dot_product(plane1.get_normal(), plane2.get_normal())) / (plane::length(plane1.get_normal()) * plane::length(plane2.get_normal()));
	double angle = acos(expression);
	return angle * coeff;
	return angle;
}

double euclidean_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_normal();
	vector<double>second_dip = plane2.get_normal();
	return sqrt(pow(first_dip[0] - second_dip[0], 2) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_normals(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double coeff = 180 / M_PI;
	return 1-(plane::dot_product(plane1.get_normal(), plane2.get_normal()) ) / (plane::length(plane1.get_normal()) * plane::length(plane2.get_normal()));
}

double angle_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double coeff = 180 / M_PI;
	double expression = abs(plane::dot_product(plane1.get_dip(), plane2.get_dip())) / (plane::length(plane1.get_dip()) * plane::length(plane2.get_dip()));
	double angle = acos(expression);
	return angle * coeff;
	return angle;
}

double euclidean_between_dip_vectors(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	vector<double>first_dip = plane1.get_dip();
	vector<double>second_dip = plane2.get_dip();
	return sqrt(  pow(first_dip[0]-second_dip[0],2    ) + pow(first_dip[1] - second_dip[1], 2) + pow(first_dip[2] - second_dip[2], 2));
}

double cosine_distance_between_dips(plane plane1, plane plane2) { //a function to calculate angles between a given triangle and neighbor triangles

	double coeff = 180 / M_PI;
	return 1 - (plane::dot_product(plane1.get_dip(), plane2.get_dip())) / (plane::length(plane1.get_dip()) * plane::length(plane2.get_dip()));
}


int main()
{
	
	std::cout << "This is generator of faulted triangulated surfaces." << std::endl;
	auto terrain_size = 1; //terrain size is fixed constant
	auto number_of_files = 1000; //number of files generated

	double converter = 180 / M_PI; // converts radians to angles and vice versa
	std::random_device rd;
	std::default_random_engine re(rd());

	int max_terrain_dip = 30; // because we have a terrain, we have a maximum limit for dip angle
	vector <int> sample_dipdir; //the surfaces will have a random dip dir and random dip direction
	vector <int> sample_dipang;
	vector <std::pair<int, int>> orientation;

	std::uniform_int_distribution<int> random_azimuth(0, 360);
	std::uniform_int_distribution<int> random_dip(0, max_terrain_dip);
	for (int i = 0; i < number_of_files; i++) { //sample values of dip direction
		sample_dipdir.push_back(random_azimuth(re)); //random_azimuth(re)
	}

	for (int i = 0; i < number_of_files; i++) { //sample values of dip angle - because we have a terrain, we have a maximum limit for dip angle
		sample_dipang.push_back(random_dip(re)); //random_dip(re)
	}

	for (int i = 0; i < number_of_files; i++) { //sample orientation
		orientation.push_back(make_pair(sample_dipang[i], sample_dipdir[i]));
	}

	vector <vector<double>>  poles;
	vector <double> triplet;

	/*cout << "x=" << -sin(max_terrain_dip / converter) * cos(0 / converter) <<
		"Y=" << -sin(max_terrain_dip / converter) * sin(0 / converter) << 
		"Z=" << -cos(max_terrain_dip / converter) << endl; */


	for (int i = 0; i < number_of_files; i++) {
		triplet.push_back(-sin(orientation[i].first / converter) * cos(orientation[i].second / converter));
		triplet.push_back(-sin(orientation[i].first / converter) * sin(orientation[i].second / converter));
		triplet.push_back(-cos(orientation[i].first / converter));
		//cout << "x=" << triplet.at(0) << "y=" << triplet.at(1) << "Z=" << triplet.at(2) << "length=" << sqrt(triplet.at(0)*triplet.at(0)+triplet.at(1)*triplet.at(1)+triplet.at(2)*triplet.at(2)) << endl;
		poles.push_back(triplet);
		triplet.clear();
	}

	int i = 1; //name or number of the file

	while (i < number_of_files)
	{
		string file_path = "C:\\testy\\scikit7\\";
		file_path.append(to_string(i));
		file_path.append(".txt");

		ofstream saving(file_path);
		saving << "X_C;" << "Y_C;" << "Z_C;" <<
			"XN;" << "YN;" << "ZN;" <<
			"XD;" << "YD;" << "ZD;" <<
			"X_C_Neighbor1;" << "Y_C_Neighbor1;" << "Z_CNeighbor1;" <<
			"X_C_Neighbor2;" << "Y_C_Neighbor2;" << "Z_CNeighbor2;" <<
			"X_C_Neighbor3;" << "Y_C_Neighbor3;" << "Z_CNeighbor3;" <<

			"EuclideanNeighbor1_N;" << "EuclideanNeighbor2_N;" << "EuclideanNeighbor3_N;" <<
			"AngleNeighbor1_N;" << "AngleNeighbor2_N;" << "AngleNeighbor3_N;" <<
			"CosineNeighbor1_N;" << "CosineNeighbor2_N;" << "CosineNeighbor3_N;" <<


			"EuclideanNeighbor1_D;" << "EuclideanNeighbor2_D;" << "EuclideanNeighbor3_D;" <<
			"AngleNeighbor1_D;" << "AngleNeighbor2_D;" << "AngleNeighbor3_D;" <<
			"CosineNeighbor1_D;" << "CosineNeighbor2_D;" << "CosineNeighbor3_D;" <<


			"n1_xn;" << "n1_yn;" << "n1_zn;" <<
			"n2_xn;" << "n2_yn;" << "n2_zn;" <<
			"n3_xn;" << "n3_yn;" << "n3_zn;" <<
			"n1_xd;" << "n1_yd;" << "n1_zd;" <<
			"n2_xd;" << "n2_yd;" << "n2_zd;" <<
			"n3_xd;" << "n3_yd;" << "n3_zd;" <<
			"IDT1;" << "IDT2;" << "IDT3;" <<
			"Fault" << endl;

		//std::uniform_int_distribution<int> number_of_points(10, 100);
		int number_of_points_triangulation = 100; // number_of_points(re); //number of points in the triangulation


		std::uniform_real_distribution<double> surface_unif(0.01, 0.05);
		std::uniform_real_distribution<double> fault_unif(0.05, 0.3); //determines the 
		double surface_fraction_of_noise = surface_unif(re); // determines what fraction of the elevation difference (max-min) can be added as noise to elevation data, e.g. 10%*980-780, where 980 and 780 are max and min elevation values, respectively
		
		
		

		vector<Point_2> points_f; //vector for storing fault lines

		Point_o_generator f(terrain_size); // faults (f), argument denotes the size of a square, the points representing a fault line lie on the boundary of the square, because we have an outside generator

		std::copy_n(f, 2, back_inserter(points_f));

		if ((points_f[0].x() == points_f[1].x()) || (points_f[0].y() == points_f[1].y())) { //we don't want ideally vertical or horizontal fault lines, because in extreme cases (if the fault line lies on the boundary), all points from the domain would have the same label
			double x3 = points_f[0].x();
			double y3 = points_f[0].y();

			points_f.erase(points_f.begin());
			points_f.insert(points_f.begin(), Point_2(y3, x3));
		}


		vector<Point_2> points_b; //vector for storing boreholes/points
		Point_i_generator b(terrain_size); // boreholes (b), argument denotes the size of a square, adding 100 points inside (because we have an inside generator)

		std::copy_n(b, number_of_points_triangulation, back_inserter(points_b));

		vector<Point> points_b_inclined; //we must add elevation


		for (auto it = points_b.begin(); it != points_b.end(); it++) {
			points_b_inclined.push_back(Point((*it).x(), (*it).y(), -poles[i][0] * (*it).x() - poles[i][1] * (*it).y())); // z=-2x-3y, web.me.utexas.edu, find an equation for the plane passing through the point Q(0,0,0) and parallel to the plane 2x+3y+z=5
		}

		auto& greatest_elev = *max_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);
		auto& smallest_elev = *min_element(points_b_inclined.begin(), points_b_inclined.end(),
			[](const Point& point1, const Point& point2) { return (point1.z() < point2.z()); }
		);


		//cout << "greatest elevation:" << greatest_elev << endl;
		//cout << "smallest elevation:" << smallest_elev << endl;
		auto elevation_difference = greatest_elev.z() - smallest_elev.z();
		auto interval_of_surface_noise = elevation_difference * surface_fraction_of_noise;
		
		//std::uniform_int_distribution<int> random_throw(0, 2*number_of_files); //we want to have enough possible fault throws
		//ouble fault_throw_fraction; //determines the fraction of elevation difference used for the fault throw
		//double value_of_fault_throw; //a vector for storing throws
		//for (int i = 0; i < number_of_files * 2; i++) {
			//fault_throw_fraction=fault_unif(re); //fractions are generated
		auto value_of_fault_throw=fault_unif(re)*1.1546 ; //fault throws are generated; 1.1547 is the maximum elevation difference between points on a terrain with maximum dip
	
		
		
		double lower_bound = -interval_of_surface_noise / 2;
		double upper_bound = interval_of_surface_noise / 2;
		std::uniform_real_distribution<double> noise_surface(lower_bound, upper_bound);

		vector<Point> points_b_inclined_noise; //we must add noise to elevation

		for (auto it = points_b_inclined.begin(); it != points_b_inclined.end(); it++) {
			points_b_inclined_noise.push_back(Point((*it).x(), (*it).y(), (*it).z() + noise_surface(re))); // 
		}


		vector< std::pair<Point, unsigned> > points_b_inclined_noise_mod;//this data structure is necessary for VTK visualization, an integer must be added to represent each point in the VTK structure
		auto number_of_point = 1; //necessary for VTK visualization
		for (auto it = points_b_inclined_noise.begin(); it != points_b_inclined_noise.end(); it++)
		{

			switch (CGAL::orientation(
				Point_2(points_f[0].x(), points_f[0].y()),
				Point_2(points_f[1].x(), points_f[1].y()),
				Point_2((*it).x(), (*it).y()))
				)
			{
			case CGAL::LEFT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z() - value_of_fault_throw), number_of_point)); break;
			case CGAL::RIGHT_TURN:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), (*it).z()), number_of_point)); break;
			case CGAL::COLLINEAR:
				points_b_inclined_noise_mod.push_back(make_pair(Point((*it).x(), (*it).y(), -9999999), number_of_point)); break;
			}

			number_of_point++;
		}

		Delaunay dt;

		dt.insert(points_b_inclined_noise_mod.begin(), points_b_inclined_noise_mod.end());
		vector<double> point_1; //four coordinates: XYZ and info
		vector<double> point_2;
		vector<double> point_3;

		vector<double> n1_point_1; //three coordinates: XYZ of neighbors
		vector<double> n1_point_2;
		vector<double> n1_point_3;

		vector<double> n2_point_1;
		vector<double> n2_point_2;
		vector<double> n2_point_3;

		vector<double> n3_point_1;
		vector<double> n3_point_2;
		vector<double> n3_point_3;

		Kernel::Line_2 f1(Point_2(points_f[0].x(), points_f[0].y()), Point_2(points_f[1].x(), points_f[1].y())); //creating one fault line


		for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

		{
			Delaunay::Face_handle face = fit;
			point_1.push_back(dt.triangle(face)[0][0]); //extracting coordinates of points building a Delaunay triangle
			point_1.push_back(dt.triangle(face)[0][1]);
			point_1.push_back(dt.triangle(face)[0][2]);
			point_1.push_back(face->vertex(0)->info());
			


			point_2.push_back(dt.triangle(face)[1][0]);
			point_2.push_back(dt.triangle(face)[1][1]);
			point_2.push_back(dt.triangle(face)[1][2]);
			point_2.push_back(face->vertex(1)->info());


			point_3.push_back(dt.triangle(face)[2][0]);
			point_3.push_back(dt.triangle(face)[2][1]);
			point_3.push_back(dt.triangle(face)[2][2]);
			point_3.push_back(face->vertex(2)->info());

			Point_2 t1(dt.triangle(face)[0][0], //extracting coordinates of points building a Delaunay triangle
				dt.triangle(face)[0][1]);

			Point_2 t2(dt.triangle(face)[1][0],
				dt.triangle(face)[1][1]);

			Point_2 t3(dt.triangle(face)[2][0],
				dt.triangle(face)[2][1]);

		//	cout << "p1:" << t1 << ", p2:" << t2 << ", t3:" << t3 << endl;

			plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
			string result = current_plane.measure();								//extracting the dip angle and the dip direction
			vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

			double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double y_n = current_plane.get_normal()[1];
			double z_n = current_plane.get_normal()[2];

			x_n = x_n / plane::length(current_plane.get_normal());
			y_n = y_n / plane::length(current_plane.get_normal());
			z_n = z_n / plane::length(current_plane.get_normal());

			double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double y_d = current_plane.get_dip()[1];
			double z_d = current_plane.get_dip()[2];

			x_d = x_d / plane::length(current_plane.get_dip());
			y_d = y_d / plane::length(current_plane.get_dip());
			z_d = z_d / plane::length(current_plane.get_dip());
			
			//Normal vectors of neighbors

			double n1_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n1_y_n;
			double n1_z_n;

			double n2_x_n;//extracting coordinates of the normal vector of a planar Delaunay triangle
			double n2_y_n;
			double n2_z_n;

			double n3_x_n; //extracting coordinates of the normal vector of a planar Delaunay triangle
			double n3_y_n;
			double n3_z_n;

			//Dip vectors of neighbors
			double d1_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d1_y_d;
			double d1_z_d;

			double d2_x_d;//extracting coordinates of the dip vector of a planar Delaunay triangle
			double d2_y_d;
			double d2_z_d;

			double d3_x_d; //extracting coordinates of the dip vector of a planar Delaunay triangle
			double d3_y_d;
			double d3_z_d;


			//1st neighbor
			double n_euclidean1 = -9999; 
			double n_angle1 = -9999;
			double n_cos1 = -9999;
			double d_euclidean1 = -9999;
			double d_angle1 = -9999;
			double d_cos1 = -9999;
			vector<string> centroid_n1;

			if (dt.is_infinite(face->neighbor(0)) == true) {


				n1_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n1_y_n = -9999;
				n1_z_n = -9999;
				d1_x_d=-9999; //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d=-9999;
				d1_z_d=-9999;
				centroid_n1.push_back("not defined");
				centroid_n1.push_back("not defined");
				centroid_n1.push_back("not defined");
				//n_euclidean1, n_angle1, n_cos1, n_euclidean1, d_angle1, d_cos1 = -9999;
			}
			else {
				n1_point_1.push_back(dt.triangle(face->neighbor(0))[0][0]); //extracting coordinates of points building a Delaunay triangle
				n1_point_1.push_back(dt.triangle(face->neighbor(0))[0][1]);
				n1_point_1.push_back(dt.triangle(face->neighbor(0))[0][2]);


				n1_point_2.push_back(dt.triangle(face->neighbor(0))[1][0]); //extracting coordinates of points building a Delaunay triangle
				n1_point_2.push_back(dt.triangle(face->neighbor(0))[1][1]);
				n1_point_2.push_back(dt.triangle(face->neighbor(0))[1][2]);


				n1_point_3.push_back(dt.triangle(face->neighbor(0))[2][0]); //extracting coordinates of points building a Delaunay triangle
				n1_point_3.push_back(dt.triangle(face->neighbor(0))[2][1]);
				n1_point_3.push_back(dt.triangle(face->neighbor(0))[2][2]);

				plane neighbor1_plane = plane(n1_point_1, n1_point_2, n1_point_3);
				n1_x_n = neighbor1_plane.get_normal()[0] / plane::length(neighbor1_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n1_y_n = neighbor1_plane.get_normal()[1] / plane::length(neighbor1_plane.get_normal());
				n1_z_n = neighbor1_plane.get_normal()[2] / plane::length(neighbor1_plane.get_normal());

				d1_x_d = neighbor1_plane.get_dip()[0] / plane::length(neighbor1_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d1_y_d = neighbor1_plane.get_dip()[1] / plane::length(neighbor1_plane.get_dip());
				d1_z_d = neighbor1_plane.get_dip()[2] / plane::length(neighbor1_plane.get_dip());


				centroid_n1 = neighbor1_plane.center();


				n_euclidean1=  euclidean_between_normals(current_plane, neighbor1_plane);
				n_angle1 = angle_between_normals(current_plane, neighbor1_plane);
				n_cos1=cosine_distance_between_normals(current_plane, neighbor1_plane);

				d_euclidean1 = euclidean_between_dip_vectors  (current_plane, neighbor1_plane);
				d_angle1 =  angle_between_dips (current_plane, neighbor1_plane);
				d_cos1 = cosine_distance_between_dips (current_plane, neighbor1_plane);
			}


			//2nd neighbor
			double n_euclidean2 = -9999;
			double n_angle2 = -9999;
			double n_cos2 = -9999;
			double d_euclidean2 = -9999;
			double d_angle2 = -9999;
			double d_cos2 = -9999;
			vector<string> centroid_n2;


			if (dt.is_infinite(face->neighbor(1)) == true) {


				n2_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n2_y_n = -9999;
				n2_z_n = -9999;


				d2_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d2_y_d = -9999;
				d2_z_d = -9999;
				centroid_n2.push_back("not defined");
				centroid_n2.push_back("not defined");
				centroid_n2.push_back("not defined");
				//n_euclidean2, n_angle2, n_cos2, n_euclidean2, d_angle2, d_cos2= -9999;
			}
			else {
				n2_point_1.push_back(dt.triangle(face->neighbor(1))[0][0]); //extracting coordinates of points building a Delaunay triangle
				n2_point_1.push_back(dt.triangle(face->neighbor(1))[0][1]);
				n2_point_1.push_back(dt.triangle(face->neighbor(1))[0][2]);


				n2_point_2.push_back(dt.triangle(face->neighbor(1))[1][0]); //extracting coordinates of points building a Delaunay triangle
				n2_point_2.push_back(dt.triangle(face->neighbor(1))[1][1]);
				n2_point_2.push_back(dt.triangle(face->neighbor(1))[1][2]);


				n2_point_3.push_back(dt.triangle(face->neighbor(1))[2][0]); //extracting coordinates of points building a Delaunay triangle
				n2_point_3.push_back(dt.triangle(face->neighbor(1))[2][1]);
				n2_point_3.push_back(dt.triangle(face->neighbor(1))[2][2]);

				plane neighbor2_plane = plane(n2_point_1, n2_point_2, n2_point_3);

				n2_x_n = neighbor2_plane.get_normal()[0] / plane::length(neighbor2_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n2_y_n = neighbor2_plane.get_normal()[1] / plane::length(neighbor2_plane.get_normal());
				n2_z_n = neighbor2_plane.get_normal()[2] / plane::length(neighbor2_plane.get_normal());

				d2_x_d = neighbor2_plane.get_dip()[0] / plane::length(neighbor2_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d2_y_d = neighbor2_plane.get_dip()[1] / plane::length(neighbor2_plane.get_dip());
				d2_z_d = neighbor2_plane.get_dip()[2] / plane::length(neighbor2_plane.get_dip());

				centroid_n2 = neighbor2_plane.center();


				n_euclidean2 = euclidean_between_normals(current_plane, neighbor2_plane);
				n_angle2 = angle_between_normals(current_plane, neighbor2_plane);
				n_cos2 = cosine_distance_between_normals(current_plane, neighbor2_plane);

				d_euclidean2 = euclidean_between_dip_vectors(current_plane, neighbor2_plane);
				d_angle2 = angle_between_dips(current_plane, neighbor2_plane);
				d_cos2 = cosine_distance_between_dips(current_plane, neighbor2_plane);
			}


			//3 neighbor

			double n_euclidean3 = -9999;
			double n_angle3 = -9999;
			double n_cos3 = -9999;
			double d_euclidean3 = -9999;
			double d_angle3 = -9999;
			double  d_cos3 = -9999;
			vector<string> centroid_n3;


			if (dt.is_infinite(face->neighbor(2)) == true) {

				n3_x_n = -9999; //fake coordinates for normal vectors of the infinite neighbor
				n3_y_n = -9999;
				n3_z_n = -9999;

				d3_x_d = -9999; //fake coordinates for dip vectors of the infinite neighbor
				d3_y_d = -9999;
				d3_z_d = -9999;

				centroid_n3.push_back("not defined");
				centroid_n3.push_back("not defined");
				centroid_n3.push_back("not defined");
				//n_euclidean3, n_angle3, n_cos3, n_euclidean3, d_angle3, d_cos3 = -9999;
			}
			else {
				n3_point_1.push_back(dt.triangle(face->neighbor(2))[0][0]); //extracting coordinates of points building a Delaunay triangle
				n3_point_1.push_back(dt.triangle(face->neighbor(2))[0][1]);
				n3_point_1.push_back(dt.triangle(face->neighbor(2))[0][2]);

				n3_point_2.push_back(dt.triangle(face->neighbor(2))[1][0]); //extracting coordinates of points building a Delaunay triangle
				n3_point_2.push_back(dt.triangle(face->neighbor(2))[1][1]);
				n3_point_2.push_back(dt.triangle(face->neighbor(2))[1][2]);

				n3_point_3.push_back(dt.triangle(face->neighbor(2))[2][0]); //extracting coordinates of points building a Delaunay triangle
				n3_point_3.push_back(dt.triangle(face->neighbor(2))[2][1]);
				n3_point_3.push_back(dt.triangle(face->neighbor(2))[2][2]);

				plane neighbor3_plane = plane(n3_point_1, n3_point_2, n3_point_3);

				n3_x_n = neighbor3_plane.get_normal()[0] / plane::length(neighbor3_plane.get_normal()); //extracting coordinates of the normal vector of a planar Delaunay triangle
				n3_y_n = neighbor3_plane.get_normal()[1] / plane::length(neighbor3_plane.get_normal());
				n3_z_n = neighbor3_plane.get_normal()[2] / plane::length(neighbor3_plane.get_normal());

				centroid_n3 = neighbor3_plane.center();


				d3_x_d = neighbor3_plane.get_dip()[0] / plane::length(neighbor3_plane.get_dip()); //fake coordinates for dip vectors of the infinite neighbor
				d3_y_d = neighbor3_plane.get_dip()[1] / plane::length(neighbor3_plane.get_dip());
				d3_z_d = neighbor3_plane.get_dip()[2] / plane::length(neighbor3_plane.get_dip());

				n_euclidean3 = euclidean_between_normals(current_plane, neighbor3_plane);
				n_angle3 = angle_between_normals(current_plane, neighbor3_plane);
				n_cos3= cosine_distance_between_normals(current_plane, neighbor3_plane);

				d_euclidean3 = euclidean_between_dip_vectors(current_plane, neighbor3_plane);
				d_angle3 = angle_between_dips(current_plane, neighbor3_plane);
				d_cos3 = cosine_distance_between_dips(current_plane, neighbor3_plane);
			}


			bool intersect = CGAL::do_intersect(Kernel::Triangle_2(t1, t2, t3), f1);

			saving <<
				centroid[0] << ";" << centroid[1] << ";" << centroid[2] << ";" <<
				x_n << ";" << y_n << ";" << z_n << ";" <<
				x_d << ";" << y_d << ";" << z_d << ";" <<
				centroid_n1[0] << ";" << centroid_n1[1] << ";" << centroid_n1[2] << ";" <<
				centroid_n2[0] << ";" << centroid_n2[1] << ";" << centroid_n2[2] << ";" <<
				centroid_n3[0] << ";" << centroid_n3[1] << ";" << centroid_n3[2] << ";" <<

				n_euclidean1 << ";" << n_euclidean2 << ";" << n_euclidean3 << ";" <<
				n_angle1 << ";" << n_angle2 << ";" << n_angle3 << ";" <<
				n_cos1 << ";" << n_cos2  << ";" << n_cos3 << ";" <<
				
				d_euclidean1 << ";" << d_euclidean2 << ";" << d_euclidean3 << ";" <<
				d_angle1 << ";" << d_angle2 << ";" << d_angle3  << ";" <<
				d_cos1 << ";" << d_cos2 << ";" << d_cos3 << ";" <<


				n1_x_n << ";" << n1_y_n << ";" << n1_z_n << ";" <<
				n2_x_n << ";" << n2_y_n << ";" << n2_z_n << ";" <<
				n3_x_n << ";" << n3_y_n << ";" << n3_z_n << ";" <<
				d1_x_d << ";" << d1_y_d << ";" << d1_z_d << ";" <<
				d2_x_d << ";" << d2_y_d << ";" << d2_z_d << ";" <<
				d3_x_d << ";" << d3_y_d << ";" << d3_z_d << ";" <<
				point_1[3] << ";" << point_2[3] << ";" << point_3[3] << ";" <<
				intersect << endl;

			string path_del = "C:\\testy\\scikit7\\";
			path_del.append(to_string(i));
			path_del.append("_delaunay.vtu");
			ofstream delaunays(path_del);

			delaunays <<
				"<?xml version=\"1.0\"?>" << "\n" <<
				"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
				"<UnstructuredGrid>" << "\n    " <<
				"<Piece NumberOfPoints=\"" << dt.number_of_vertices() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "
				"<PointData Scalars=\"scalars\">" << "\n        "
				"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";

			for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
			{
				delaunays << fixed << (it->first[2]) << "\n          ";
			}

			delaunays << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</PointData>" << "\n      " <<
				"<Points>" << "\n        " <<
				"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

			for (auto it = points_b_inclined_noise_mod.begin(); it != points_b_inclined_noise_mod.end(); it++)
			{
				double x = (it->first[1]), y = (it->first[0]), z = (it->first[2]);
				delaunays << fixed << x << " " << y << " " << z << "\n           ";
			}

			delaunays << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Points>" << "\n      " <<
				"<Cells>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
			{
				Delaunay::Face_handle face = fit;
				delaunays << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";

				//cout << face->vertex(0)->info() - 1 << " " << face->vertex(1)->info() - 1 << " " << face->vertex(2)->info() - 1 << "\n";
			}

			delaunays << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

			for (auto i = 3; i <= 3 * dt.number_of_faces(); i = i + 3)
			{
				delaunays << i << " ";
			}

			delaunays << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
				"\n          ";

			for (auto i = 1; i <= dt.number_of_faces(); i++)
			{
				delaunays << 5 << " ";
			}

			delaunays << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Cells>" << "\n    " <<
				"</Piece>" << "\n  " <<
				"</UnstructuredGrid>" << "\n" <<
				"</VTKFile>";

			string path_normals = "C:\\testy\\scikit7\\";
			path_normals.append(to_string(i));
			path_normals.append("_normals.vtu");
			ofstream normalvis(path_normals);

			normalvis <<
				"<?xml version=\"1.0\"?>" << "\n" <<
				"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
				"<UnstructuredGrid>" << "\n    " <<
				"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

				"<PointData Scalars=\"scalars\">" << "\n        "
				"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

			{
				Delaunay::Face_handle face = fit;
				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
				normalvis << fixed << centroid[2] << "\n          ";
			}

			normalvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</PointData>" << "\n      " <<
				"<Points>" << "\n        " <<
				"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

			{
				Delaunay::Face_handle face = fit;
				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				string result = current_plane.measure();								//extracting the dip angle and the dip direction
				vector <string> centroid = current_plane.center();

				normalvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

			}

			normalvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Points>" << "\n      " <<
				"<Cells>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

			for (auto i = 0; i < dt.number_of_faces(); i++)
			{
				normalvis << i << "\n          ";
			}

			normalvis << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

			for (auto i = 1; i <= dt.number_of_faces(); i++)
			{
				normalvis << i << " ";
			}

			normalvis << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
				"\n          ";

			for (auto i = 1; i <= dt.number_of_faces(); i++)
			{
				normalvis << 1 << " ";
			}

			normalvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Cells>" << "\n    " <<
				"<CellData Normals=\"cell_normals\">" << "\n      " <<
				"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
			{
				Delaunay::Face_handle face = fit;

				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				string result = current_plane.measure();								//extracting the dip angle and the dip direction
				vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

				double x_n = current_plane.get_normal()[0]; //extracting coordinates of the normal vector of a planar Delaunay triangle
				double y_n = current_plane.get_normal()[1];
				double z_n = current_plane.get_normal()[2];

				vector<double> normal_vector_double = { x_n, y_n, z_n };
				x_n = x_n / plane::length(normal_vector_double);
				y_n = y_n / plane::length(normal_vector_double);
				z_n = z_n / plane::length(normal_vector_double);

				normalvis << fixed << y_n << " " << x_n << " " << z_n << "\n          ";
			}

			normalvis <<
				"</DataArray>" << "\n      " <<
				"</CellData>" << "\n      " <<
				"<Cells>" << "\n        " <<
				"</Cells>" << "\n    " <<
				"</Piece>" << "\n  " <<
				"</UnstructuredGrid>" << "\n" <<
				"</VTKFile>";


			//VTK file for Dip vectors

			string path_dips = "C:\\testy\\scikit7\\";
			path_dips.append(to_string(i));
			path_dips.append("_dips.vtu");
			ofstream dipsvis(path_dips);

			dipsvis <<
				"<?xml version=\"1.0\"?>" << "\n" <<
				"<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">" << "\n  " <<
				"<UnstructuredGrid>" << "\n    " <<
				"<Piece NumberOfPoints=\"" << dt.number_of_faces() << "\" NumberOfCells=\"" << dt.number_of_faces() << "\">" << "\n      "

				"<PointData Scalars=\"scalars\">" << "\n        "
				"<DataArray type=\"Float32\" Name=\"scalars\" format=\"ascii\">" << "\n          ";


			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

			{
				Delaunay::Face_handle face = fit;
				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				vector<string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle
				dipsvis << fixed << centroid[2] << "\n          ";
			}

			dipsvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</PointData>" << "\n      " <<
				"<Points>" << "\n        " <<
				"<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n           ";

			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) //a loop for performing the Delaunay triangulation and save the results

			{
				Delaunay::Face_handle face = fit;
				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				string result = current_plane.measure();								//extracting the dip angle and the dip direction
				vector <string> centroid = current_plane.center();

				dipsvis << fixed << centroid[1] << " " << centroid[0] << " " << centroid[2] << "\n           ";

			}

			dipsvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Points>" << "\n      " <<
				"<Cells>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">" << "\n          ";

			for (auto i = 0; i < dt.number_of_faces(); i++)
			{
				dipsvis << i << "\n          ";
			}

			dipsvis << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">" << "\n          ";

			for (auto i = 1; i <= dt.number_of_faces(); i++)
			{
				dipsvis << i << " ";
			}

			dipsvis << "\n        " <<
				"</DataArray>" << "\n        " <<
				"<DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">" <<
				"\n          ";

			for (auto i = 1; i <= dt.number_of_faces(); i++)
			{
				dipsvis << 1 << " ";
			}

			dipsvis << "\n        " <<
				"</DataArray>" << "\n      " <<
				"</Cells>" << "\n    " <<
				"<CellData Normals=\"cell_normals\">" << "\n      " <<
				"<DataArray type=\"Float32\" Name=\"cell_normals\" NumberOfComponents=\"3\" format=\"ascii\">" << "\n          ";


			for (Delaunay::Finite_faces_iterator fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit)
			{
				Delaunay::Face_handle face = fit;

				point_1[0] = dt.triangle(face)[0][0]; //extracting coordinates of points building a Delaunay triangle
				point_1[1] = dt.triangle(face)[0][1];
				point_1[2] = dt.triangle(face)[0][2];
				point_1[3] = face->vertex(0)->info();

				point_2[0] = dt.triangle(face)[1][0];
				point_2[1] = dt.triangle(face)[1][1];
				point_2[2] = dt.triangle(face)[1][2];
				point_2[3] = face->vertex(1)->info();

				point_3[0] = dt.triangle(face)[2][0];
				point_3[1] = dt.triangle(face)[2][1];
				point_3[2] = dt.triangle(face)[2][2];
				point_3[3] = face->vertex(2)->info();

				plane current_plane = plane(point_1, point_2, point_3);					//constructing a plane that is processed at the moment
				string result = current_plane.measure();								//extracting the dip angle and the dip direction
				vector <string> centroid = current_plane.center();		//extracting the centroid of a Delaunay triangle

				double x_d = current_plane.get_dip()[0]; //extracting coordinates of the dip vector of a planar Delaunay triangle
				double y_d = current_plane.get_dip()[1];
				double z_d = current_plane.get_dip()[2];

				vector<double> dip_vector_double = { x_d, y_d, z_d };
				x_d = x_d / plane::length(dip_vector_double);
				y_d = y_d / plane::length(dip_vector_double);
				z_d = z_d / plane::length(dip_vector_double);

				dipsvis << fixed << y_d << " " << x_d << " " << z_d << "\n          ";
			}

			dipsvis <<
				"</DataArray>" << "\n      " <<
				"</CellData>" << "\n      " <<
				"<Cells>" << "\n        " <<
				"</Cells>" << "\n    " <<
				"</Piece>" << "\n  " <<
				"</UnstructuredGrid>" << "\n" <<
				"</VTKFile>";  





			//the end of the big for loop

			point_1.clear();
			point_2.clear();
			point_3.clear();

			n1_point_1.clear();
			n1_point_2.clear();
			n1_point_3.clear();

			n2_point_1.clear();
			n2_point_2.clear();
			n2_point_3.clear();

			n3_point_1.clear();
			n3_point_2.clear();
			n3_point_3.clear();
		}




		i++;
	}


	system("pause");
	return 0;
}
